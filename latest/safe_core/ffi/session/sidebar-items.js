initSidebarItems({"fn":[["client_issued_appends","Return the amount of calls that were done to `append`"],["client_issued_deletes","Return the amount of calls that were done to `delete`"],["client_issued_gets","Return the amount of calls that were done to `get`"],["client_issued_posts","Return the amount of calls that were done to `post`"],["client_issued_puts","Return the amount of calls that were done to `put`"],["create_account","Create a registered client. This or any one of the other companion functions to get a session must be called before initiating any operation allowed by this crate. `session_handle` is a pointer to a pointer and must point to a valid pointer not junk, else the consequences are undefined."],["create_unregistered_client","Create a session as an unregistered client. This or any one of the other companion functions to get a session must be called before initiating any operation allowed by this crate."],["drop_session","Discard and clean up the previously allocated session. Use this only if the session is obtained from one of the session obtainment functions in this crate (`create_account`, `log_in`, `create_unregistered_client`). Using `session` after a call to this functions is undefined behaviour."],["get_account_info","Get data from the network. This is non-blocking. `data_stored` means number of chunks Put. `space_available` means number of chunks which can still be Put."],["log_in","Log into a registered client. This or any one of the other companion functions to get a session must be called before initiating any operation allowed by this crate. `session_handle` is a pointer to a pointer and must point to a valid pointer not junk, else the consequences are undefined."],["register_network_event_observer","Register an observer to network events like Connected, Disconnected etc. as provided by the core module"]],"struct":[["Session","Represents user session on the SAFE network. There should be one session per launcher."]],"type":[["SessionHandle","Clonable handle to Session."]]});