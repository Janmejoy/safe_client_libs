initSidebarItems({"constant":[["COMPRESSION_QUALITY","Controls the compression-speed vs compression-density tradeoffs.  The higher the quality, the slower the compression.  Range is 0 to 11."],["MAX_CHUNK_SIZE","The maximum size (before compression) of an individual chunk of the file, defined as 1MB."],["MAX_FILE_SIZE","The maximum size of file which can be self-encrypted, defined as 1GB."],["MIN_CHUNK_SIZE","The minimum size (before compression) of an individual chunk of the file, defined as 1kB."]],"enum":[["DataMap","Holds the information that is required to recover the content of the encrypted file.  Depending on the file size, this is held as a vector of `ChunkDetails`, or as raw data."],["SelfEncryptionError","Errors which can arise during self-encryption or -decryption."]],"struct":[["ChunkDetails","Holds pre- and post-encryption hashes as well as the original (pre-compression) size for a given chunk."],["SelfEncryptor","This is the encryption object and all file handling should be done using this object as the low level mechanism to read and write *content*.  This library has no knowledge of file metadata."],["SequentialEncryptor","An encryptor which only permits sequential writes, i.e. there is no ability to specify an offset in the `write()` call; all data is appended sequentially."]],"trait":[["Storage","Trait which must be implemented by storage objects to be used in self-encryption.  Data is passed to the storage object encrypted with `name` being the SHA512 hash of `data`.  `Storage` could be implemented as an in-memory `HashMap` or a disk-based container for example."],["StorageError","Trait inherited from `std::error::Error` representing errors which can be returned by the `Storage` object."]]});